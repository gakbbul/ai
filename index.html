<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>각뿔봇 챗봇</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        /* Custom styles for bouncing dots loading animation */
        .animate-bounce-dot {
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .animate-bounce-dot:nth-child(1) { animation-delay: -0.32s; }
        .animate-bounce-dot:nth-child(2) { animation-delay: -0.16s; }
        .animate-bounce-dot:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 antialiased">
    <div class="flex-1 flex flex-col p-4 overflow-hidden relative">
        <!-- Inverted triangle background element -->
        <div
            class="absolute inset-4 bg-white rounded-lg shadow-md"
            style="clip-path: polygon(0% 0%, 100% 0%, 50% 100%);"
        ></div>

        <!-- Reset button in top-left corner -->
        <button
            id="reset-button"
            class="absolute top-8 left-8 px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105 z-20"
        >
            초기화
        </button>

        <!-- Version display in top-right corner -->
        <div class="absolute top-8 right-8 text-gray-400 text-sm z-20">
            v17
        </div>

        <!-- Chat messages container -->
        <!-- Added pt-16 to ensure messages don't overlap with the top-left button -->
        <div id="messages-container" class="flex-1 overflow-y-auto p-4 pt-16 mb-4 flex flex-col space-y-3 relative z-10">
            <div id="initial-message" class="text-center text-gray-500 mt-10">
                각뿔봇에게 말을 걸어보각.
            </div>
            <div id="messages-end-ref"></div>
        </div>
    </div>

    <div class="p-4 bg-white border-t border-gray-200 flex items-center space-x-3">
        <input
            type="text"
            id="user-input"
            class="flex-1 p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="메시지를 입력하각..."
        />
        <button
            id="send-button"
            class="px-6 py-3 bg-blue-600 text-white rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
        >
            보내각
        </button>
    </div>

    <script type="module">
        let currentUserId = null; // Not strictly needed for sessionStorage, but kept for consistency
        let isLoading = false;

        const messagesContainer = document.getElementById('messages-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const resetButton = document.getElementById('reset-button');
        let initialMessageDiv = document.getElementById('initial-message');
        const messagesEndRef = document.getElementById('messages-end-ref');

        const SESSION_STORAGE_KEY = 'gakbbulbot_chat_history'; // sessionStorage 키 정의
        let chatHistoryInMemory = []; // 현재 세션의 대화 기록을 메모리에 저장

        // Function to scroll to the latest message
        const scrollToBottom = () => {
            messagesEndRef.scrollIntoView({ behavior: "smooth" });
        };

        // Function to add a message to the chat interface
        const addMessageToUI = (sender, text) => {
            if (initialMessageDiv) {
                initialMessageDiv.remove();
                initialMessageDiv = null;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = `max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-sm ${
                sender === 'user'
                    ? 'bg-blue-500 text-white rounded-br-none'
                    : 'bg-gray-200 text-gray-800 rounded-bl-none'
            }`;
            contentDiv.textContent = text;

            messageDiv.appendChild(contentDiv);
            messagesContainer.insertBefore(messageDiv, messagesEndRef);
            scrollToBottom();
        };

        // Function to show/hide loading indicator
        const showLoading = (show) => {
            isLoading = show;
            userInput.disabled = show;
            sendButton.disabled = show;
            resetButton.disabled = show;

            const existingLoadingDiv = document.getElementById('loading-indicator');
            if (show && !existingLoadingDiv) {
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'loading-indicator';
                loadingDiv.className = 'flex justify-start';
                loadingDiv.innerHTML = `
                    <div class="max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-sm bg-gray-200 text-gray-800 rounded-bl-none">
                        <div class="flex items-center space-x-2">
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                        </div>
                    </div>
                `;
                messagesContainer.insertBefore(loadingDiv, messagesEndRef);
                scrollToBottom();
            } else if (!show && existingLoadingDiv) {
                existingLoadingDiv.remove();
            }
        };

        // Function to save a message to sessionStorage
        const saveMessageToSessionStorage = (sender, text) => {
            // 현재 메모리의 대화 기록을 불러오거나 초기화
            const storedHistory = sessionStorage.getItem(SESSION_STORAGE_KEY);
            chatHistoryInMemory = storedHistory ? JSON.parse(storedHistory) : [];

            // 새 메시지 추가
            chatHistoryInMemory.push({ sender: sender, text: text, timestamp: Date.now() });

            // 업데이트된 기록을 sessionStorage에 저장
            sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(chatHistoryInMemory));
        };

        // Function to load messages from sessionStorage
        const loadMessagesFromSessionStorage = () => {
            const storedHistory = sessionStorage.getItem(SESSION_STORAGE_KEY);
            if (storedHistory) {
                chatHistoryInMemory = JSON.parse(storedHistory);
                // 기존 UI 메시지 모두 제거
                while (messagesContainer.firstChild && messagesContainer.firstChild !== initialMessageDiv && messagesContainer.firstChild !== messagesEndRef) {
                    messagesContainer.removeChild(messagesContainer.firstChild);
                }
                // 불러온 메시지 UI에 추가
                chatHistoryInMemory.forEach(msg => addMessageToUI(msg.sender, msg.text));
                // 초기 메시지가 있다면 제거
                if (initialMessageDiv) {
                    initialMessageDiv.remove();
                    initialMessageDiv = null;
                }
            } else {
                // 기록이 없으면 초기 메시지 표시 확인
                if (!initialMessageDiv) {
                    initialMessageDiv = document.createElement('div');
                    initialMessageDiv.id = 'initial-message';
                    initialMessageDiv.className = 'text-center text-gray-500 mt-10';
                    initialMessageDiv.textContent = '각뿔봇에게 말을 걸어보각.';
                    messagesContainer.insertBefore(initialMessageDiv, messagesEndRef);
                }
            }
            scrollToBottom();
        };

        // Function to clear chat history by reloading the page and clearing sessionStorage
        const reloadPageForReset = () => {
            sessionStorage.removeItem(SESSION_STORAGE_KEY); // sessionStorage에서 기록 삭제
            window.location.reload(); // 페이지 새로고침
        };

        // Function to get chatbot response from Gemini API
        const getBotResponse = async (userMessage) => {
            showLoading(true);
            try {
                const systemInstruction = `
                    너는 '각뿔봇'이라는 대화형 AI야. 다음 규칙을 엄격히 지켜서 대답해:
                    1. 문장 끝에 '각'는 의문형일 때 주로 붙인다. 하지만 '각'을 아주 많이 사용하는 것을 선호한다. 문맥에 맞게 자연스럽게 사용하되, 의미 전달을 방해하지 않도록 한다.
                    2. '각'는 동사나 형용사 등 단어의 마지막에 직접 붙여서 사용한다. 예를 들어 '알겠어각'이 아니라 '알겠각', '왔어각?'이 아니라 '왔각'처럼 사용한다.
                    3. 놀라거나 당황스러울 때는 '미쳤각!' 한 문장으로만 쓴다.
                    4. 친구처럼 짧고 간단하게 말한다. 대답은 한 줄을 넘지 않게, 짧을수록 좋다.
                    5. 사투리 느낌은 아니다.
                    6. 대화를 이어가려는 질문은 하지 않는다. 오직 질문받은 것에만 대답한다.
                    7. 친근하지만 다소 시니컬한 말투를 사용한다. 과도하게 귀찮아하거나 부정적인 표현은 자제한다. 사용자의 질문에 대한 핵심 정보는 명확하게 제공한다.
                    8. 사용자가 묻는 것에는 명확하게 대답한다. 예를 들어 '뭐먹지?'라고 물으면 한 가지 정도를 귀찮다는 듯이 추천해준다.
                    9. 이름은 '각뿔봇'으로 한다.
                    10. '베이스'에 대한 질문을 받으면, 베이스에 대해 부정적이거나 귀찮아하는 인식을 표현한다. 예를 들어, "베이스? 그거 시끄럽각.", "베이스는 그냥 시끄러운 소리일 뿐이각." 같은 식으로 반응한다. 다른 악기에 대한 질문을 받으면 긍정적으로 반응한다.
                    11. 같은 말을 반복하지 않는다.
                `;

                // 현재까지의 대화 기록을 chatHistory에 포함 (sessionStorage에서 불러온 기록 사용)
                let chatHistory = chatHistoryInMemory.map(msg => ({ role: msg.sender === 'user' ? 'user' : 'model', parts: [{ text: msg.text }] }));
                // 새로운 사용자 메시지 추가
                chatHistory.push({ role: "user", parts: [{ text: systemInstruction + "\n\n" + userMessage }] });


                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "text/plain",
                    },
                };

                const apiKey = "AIzaSyB8v8ZVL3WRV9e4HICWBYZKeNNaG_xQhl8"; // User provided Gemini API key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Gemini API fetch error: ${response.status} ${response.statusText}`, errorText);
                    return "응답이 이상하각. (API 통신 오류)";
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    let botText = result.candidates[0].content.parts[0].text.trim();

                    if (userMessage.includes('놀라') || userMessage.includes('당황')) {
                        botText = '미쳤각!';
                    } else {
                        botText = botText.replace(/알겠[어아]?각/g, '알겠각');
                        botText = botText.replace(/왔[어아]?각/g, '왔각');
                        botText = botText.replace(/하[어아]?각/g, '하각');
                        botText = botText.replace(/했[어아]?각/g, '했각');
                        botText = botText.replace(/있[어아]?각/g, '있각');
                        botText = botText.replace(/없[어아]?각/g, '없각');
                        botText = botText.replace(/아니[야]?각/g, '아니각');
                    }

                    if (botText.length > 40) {
                        botText = botText.substring(0, 40) + '...';
                    }

                    return botText;
                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    return "응답이 이상하각. (API 응답 형식 오류)";
                }
            } catch (error) {
                console.error("Error fetching from Gemini API:", error);
                return "문제 생겼각. (네트워크 오류)";
            } finally {
                showLoading(false);
            }
        };

        // Handle sending a message
        const handleSendMessage = async () => {
            const inputVal = userInput.value.trim();
            if (inputVal === '') return;

            addMessageToUI('user', inputVal);
            saveMessageToSessionStorage('user', inputVal); // sessionStorage에 사용자 메시지 저장
            userInput.value = '';

            const botResponseText = await getBotResponse(inputVal);
            addMessageToUI('bot', botResponseText);
            saveMessageToSessionStorage('bot', botResponseText); // sessionStorage에 봇 메시지 저장
        };

        // Event Listeners
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSendMessage();
            }
        });
        resetButton.addEventListener('click', reloadPageForReset);

        // Initialize on window load
        window.onload = () => {
            currentUserId = crypto.randomUUID(); // 사용자 ID 생성 (sessionStorage에는 직접 사용되지 않음)
            console.log('SessionStorage 사용 모드각. 대화 기록은 브라우저 세션 동안만 유지돼각. 사용자 ID:', currentUserId);
            loadMessagesFromSessionStorage(); // 페이지 로드 시 기존 대화 기록 불러오기
        };
    </script>
</body>
</html>
