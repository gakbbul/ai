<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>각뿔봇 챗봇</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Quill CSS (Not used, but keeping for compatibility if user wants to go forward) -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        /* Universal reset for box-sizing */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        html, body { /* Ensure full viewport height for both html and body */
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif;
            font-weight: 400; /* Default font-weight */
            overflow: hidden; /* Prevent body scroll, flexbox will handle internal scrolling */
        }

        /* Custom styles for bouncing dots loading animation */
        .animate-bounce-dot {
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .animate-bounce-dot:nth-child(1) { animation-delay: -0.32s; }
        .animate-bounce-dot:nth-child(2) { animation-delay: -0.16s; }
        .animate-bounce-dot:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
        /* Style for modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow-y: auto; /* Allow scrolling within the overlay */
            padding: 1rem; /* Add padding for small screens */
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            width: 80%; /* Default width for modals */
            max-width: 600px; /* Max width for larger screens */
            height: auto; /* Auto height for content */
            max-height: 90vh; /* Max height for responsiveness */
            overflow-y: auto; /* Allow scrolling within the modal content */
            position: relative;
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack children vertically */
        }
        .modal-content h1 {
            font-size: 2.5rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            margin-bottom: 1.5rem;
            color: #1f2937; /* text-gray-900 */
        }
        .modal-content h2 {
            font-size: 1.75rem; /* text-2xl */
            font-weight: 600; /* font-semibold */
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        .modal-content ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        .modal-content li {
            margin-bottom: 0.5rem;
        }
        .modal-content strong {
            font-weight: 700;
        }

        /* Quill editor styles (not used in this version) */
        #changelog-editor-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        #changelog-editor {
            flex-grow: 1;
            border: 1px solid #ccc;
            min-height: 200px;
            background-color: #f8f8f8;
            padding: 1rem;
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }

        .ql-toolbar {
            border: 1px solid #ccc;
            border-bottom: none;
            padding: 8px;
            background-color: #f0f0f0;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }

        .ql-container {
            border: none !important;
            flex-grow: 1;
            overflow-y: auto;
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-100 antialiased">
    <!-- 변경 사항 내용을 여기에 직접 작성하세요. (HTML 형식) -->
    <!-- This div will now serve as the static changelog content -->
    <div id="changelog-data" class="hidden">
        <h2>v49</h2>
        <ul>
            <li>**랜덤 게임 기능 추가 및 개선:** 369게임, 끝말잇기, 초성게임, 스무고개 등 다양한 랜덤 게임 기능이 추가됐각.</li>
            <li>**끝말잇기 게임 규칙 개선:** 각뿔봇이 대답에 '각'를 붙이지 않으며, 사용자가 사전에 없는 단어를 말하거나 중복된 단어를 사용하면 게임이 종료되각. 각뿔봇이 낼 단어가 없어도 게임이 종료되각.</li>
            <li>**초성게임 규칙 개선:** 사용자가 "초성게임 시작하각!"이라고 말하면 5개의 초성 문제가 출제되고, 사용자가 사전에 있는 단어 중 초성이 일치하는 단어를 말하면 정답으로 인정하각. 사전에 없는 단어를 말하면 게임이 종료되각.</li>
            <li>**입력창 자동 포커스 기능 추가:** 메시지 전송 후 입력창이 자동으로 선택되어 바로 다음 메시지를 입력할 수 있각 (데스크톱 환경에 한정).</li>
            <li>**내부 오류 수정:** 'getBotResponse' 함수 관련 오류 등 내부적인 안정성 문제가 해결됐각.</li>
        </ul>
        <h2>v47</h2>
        <ul>
            <li>**말투 변경:** 변경 사항 내용을 각뿔봇 말투로 다듬었각.</li>
        </ul>
        <h2>v46</h2>
        <ul>
            <li>**유머 학습:** 각뿔봇이 아재개그나 유머에 더 잘 반응하도록 학습했각.</li>
        </ul>
        <h2>v45</h2>
        <ul>
            <li>**메시지 표시 오류 수정:** 각뿔봇의 응답이 화면에 나타나지 않던 문제를 해결했각.</li>
        </ul>
        <h2>v44</h2>
        <ul>
            <li>**변경 사항 표시 방식 개선:** '변경 사항'을 누르면 앱 안에서 바로 모달 창으로 표시되도록 변경했각.</li>
            <li>**불필요한 내용 정리:** 사용자가 직접적으로 체감하기 어려운 내부적인 변경 내용은 목록에서 제외했각.</li>
        </ul>
        <h2>v43</h2>
        <ul>
            <li>**오류 해결:** 'handleSendMessage' 관련 오류를 해결했각.</li>
        </ul>
        <h2>v39</h2>
        <ul>
            <li>**API 키 직접 설정:** 깃허브 페이지에서 앱이 작동하도록 API 키를 코드에 직접 적용했각.</li>
        </ul>
        <h2>v38</h2>
        <ul>
            <li>**불필요한 기능 삭제:** Firebase 관련 기능 및 직접 삽입된 Gemini API 키를 제거했각.</li>
        </ul>
        <h2>v37</h2>
        <ul>
            <li>**API 키 적용:** 제공된 API 키를 코드에 적용했각.</li>
        </ul>
        <h2>v28</h2>
        <ul>
            <li>**변경 사항 편집 기능 추가:** 비밀번호를 입력하면 '변경 사항' 내용을 직접 수정하고 저장할 수 있각.</li>
            <li>**화면 레이아웃 복구:** 이전 버전에서 깨졌던 화면 레이아웃을 v24 버전으로 되돌렸각.</li>
            <li>**기존 개선 사항 유지:** 'TypeError' 버그 수정(v26)과 날짜 질문 개선(v25) 기능은 유지했각.</li>
        </ul>
        <h2>v27</h2>
        <ul>
            <li>**레이아웃 개선 시도 (롤백):** 화면 레이아웃과 글씨 굵기를 개선하려 했으나, 불편해져 v28에서 되돌렸각.</li>
        </ul>

        <h2>v26</h2>
        <ul>
            <li>**내부 오류 수정:** 특정 시스템 오류를 수정하여 앱 안정성을 개선했각.</li>
        </ul>

        <h2>v25</h2>
        <ul>
            <li>**날짜 질문 개선:** 각뿔봇이 날짜를 물어보면 현재 날짜를 더 정확하게 알려주도록 개선했각.</li>
        </ul>

        <h2>v24</h2>
        <ul>
            <li>**프로필 창 크기 조정:** 프로필 창의 크기를 키웠각.</li>
            <li>**변경 사항 날짜 제거:** 변경 사항 목록에서 각 버전 옆에 표시되던 날짜를 제거했각.</li>
        </ul>

        <h2>v23</h2>
        <ul>
            <li>**닫기 버튼 색상 변경:** 변경 사항 창과 프로필 창의 '닫기' 버튼 색깔을 회색으로 변경했각.</li>
        </ul>

        <h2>v22</h2>
        <ul>
            <li>**프로필 기능 추가:** 이름과 알려주고 싶은 점을 저장할 수 있는 '프로필' 기능이 추가됐각.</li>
            <li>**개인 맞춤 대화:** 프로필 정보를 기억하여 더 맞춤형으로 대화할 수 있게 됐각.</li>
            <li>**프로필 정보 영구 저장:** 프로필 정보가 브라우저를 닫아도 사라지지 않고 기억되도록 변경했각. (대화 기록은 탭을 닫으면 사라지각.)</li>
        </ul>
        <h2>v21</h2>
        <ul>
            <li>**변경 사항 모달 창:** '변경 사항' 버튼 클릭 시 새 페이지로 이동하지 않고, 현재 화면에 팝업처럼 뜨도록 수정했각.</li>
            <li>**메뉴 버튼 시각 개선:** 메뉴가 열리면 메뉴 버튼 색상이 연하게 변경되도록 개선했각.</li>
        </ul>
        <h2>v20</h2>
        <ul>
            <li>**메뉴 버튼 반응 추가:** 왼쪽 상단 메뉴 버튼 클릭 시 색상이 변경되도록 시각적 피드백을 추가했각.</li>
            <li>**'변경 사항' 버튼 추가:** 메뉴 드롭다운에 '변경 사항' 버튼을 추가했각.</li>
            <li>**'보내각' 버튼 글자 고정:** 모바일 환경에서 '보내각' 버튼 텍스트가 줄 바꿈 되는 문제를 해결했각.</li>
        </ul>
        <h2>v19</h2>
        <ul>
            <li>**기록 저장 방식 변경:** 대화 기록 저장 방식을 Firebase에서 SessionStorage로 변경했각. (브라우저 탭을 닫으면 대화 기록 초기화)</li>
            <li>**불필요한 메시지 제거:** Firebase 관련 오류 메시지가 더 이상 표시되지 않도록 했각.</li>
        </ul>
        <h2>v18</h2>
        <ul>
            <li>**API 키 업데이트:** Gemini API 키를 코드에 적용했각.</li>
            <li>**API 오류 메시지 개선:** Gemini API 통신 오류 시 더 자세한 오류 메시지를 표시하도록 개선했각.</li>
        </ul>
        <h2>v17</h2>
        <ul>
            <li>**초기화 버튼 색상 변경:** '대화 초기화' 버튼의 색상을 회색으로 변경했각.</li>
        </ul>
        <h2>v16</h2>
        <ul>
            <li>**초기화 버튼 위치 이동:** '대화 초기화' 버튼을 화면 왼쪽 상단으로 이동했각.</li>
            <li>**메시지 간격 조정:** 초기화 버튼과 메시지가 겹치지 않도록 채팅 메시지 컨테이너의 상단 패딩을 조정했각.</li>
        </ul>
        <h2>v15</h2>
        <ul>
            <li>**버전 표시:** 앱 오른쪽 상단에 현재 버전(v15)을 작게 표시하도록 했각.</li>
        </ul>
        <h2>v14</h2>
        <ul>
            <li>**대화 초기화 버튼 추가:** 대화 내용을 처음부터 다시 시작할 수 있는 버튼이 추가됐각.</li>
            <li>**사용자 ID 숨김:** 사용자 ID가 화면에 표시되지 않도록 변경했각.</li>
            <li>**대화 내용 기억:** 브라우저 세션 동안 대화 내용을 기억하도록 구현했각.</li>
            <li>**Gemini API 연동:** Gemini API를 연동하여 질문에 대답하고, '베이스'에 대한 특정 반응을 보이도록 설정했각.</li>
        </ul>
        <!-- 여기에 새로운 변경 사항을 추가하세요. -->
    </div>

    <div class="flex-1 flex flex-col p-4 overflow-hidden relative">
        <!-- Inverted triangle background element -->
        <div
            class="absolute inset-4 bg-white rounded-lg shadow-md"
            style="clip-path: polygon(0% 0%, 100% 0%, 50% 100%);"
        ></div>

        <!-- Top Left Section: Menu and Random Game Button -->
        <div class="absolute top-8 left-8 z-30 flex items-center space-x-3">
            <button id="menu-button" class="p-2 bg-gray-700 rounded-full shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105">
                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
            <div id="dropdown-menu" class="absolute top-full left-0 mt-2 w-40 bg-white rounded-lg shadow-lg hidden">
                <button
                    id="reset-button"
                    class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-100 rounded-lg transition duration-150 ease-in-out"
                >
                    대화 초기화
                </button>
                <button
                    id="changelog-button"
                    class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-100 rounded-lg transition duration-150 ease-in-out"
                >
                    변경 사항
                </button>
                <button
                    id="profile-button"
                    class="block w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-100 rounded-lg transition duration-150 ease-in-out"
                >
                    프로필
                </button>
            </div>
            <button
                id="random-game-button"
                class="px-4 py-2 bg-purple-600 text-white rounded-full shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105 whitespace-nowrap"
            >
                랜덤게임
            </button>
        </div>

        <!-- Top Right Section: Version Display -->
        <div class="absolute top-8 right-8 text-gray-400 text-sm z-20">
            v49
        </div>

        <!-- User ID Display (Removed Firebase dependency) -->
        <!-- <div class="absolute top-8 left-1/2 -translate-x-1/2 text-gray-400 text-sm z-20">
            <span id="user-id-display">사용자 ID: 로딩 중...</span>
        </div> -->

        <!-- Chat messages container -->
        <div id="messages-container" class="flex-1 overflow-y-auto p-4 pt-24 mb-4 flex flex-col space-y-3 relative z-10">
            <div id="initial-message" class="text-center text-gray-500 mt-10">
                각뿔봇에게 말을 걸어보각.
            </div>
            <div id="messages-end-ref"></div>
        </div>
    </div>

    <div class="p-4 bg-white border-t border-gray-200 flex items-center space-x-3">
        <input
            type="text"
            id="user-input"
            class="flex-1 p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="메시지를 입력하각..."
        />
        <button
            id="send-button"
            class="px-6 py-3 bg-blue-600 text-white rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105 whitespace-nowrap"
        >
            보내각
        </button>
    </div>

    <!-- Changelog Modal -->
    <div id="changelog-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6 border-b pb-4">
                <h1 class="text-4xl font-bold">각뿔봇 변경 사항</h1>
                <button
                    id="close-changelog-button"
                    class="px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                >
                    닫기
                </button>
            </div>
            <div id="changelog-display-content" class="prose max-w-none">
                <!-- Changelog content will be loaded here by JavaScript -->
            </div>

            <!-- Changelog Auth Section (Removed Firebase dependency) -->
            <!-- <div id="changelog-auth-section" class="mt-4 flex flex-col space-y-3">
                <input
                    type="password"
                    id="changelog-password"
                    class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="비밀번호를 입력하각..."
                />
                <button
                    id="unlock-changelog-button"
                    class="w-full px-6 py-3 bg-gray-600 text-white rounded-xl shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                >
                    편집 잠금 해제
                </button>
            </div> -->

            <!-- Changelog Edit Section (Removed Firebase dependency) -->
            <!-- <div id="changelog-edit-section" class="mt-4 hidden flex flex-col flex-grow space-y-3">
                <textarea
                    id="changelog-editor"
                    class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    rows="10"
                    placeholder="변경 사항 내용을 입력하각..."
                ></textarea>
                <div class="flex justify-end space-x-3">
                    <button
                        id="save-changelog-edits"
                        class="px-6 py-3 bg-blue-600 text-white rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                    >
                        저장
                    </button>
                    <button
                        id="cancel-changelog-edits"
                        class="px-6 py-3 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus-ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                    >
                        취소
                    </button>
                </div>
            </div> -->

            <div id="changelog-status" class="text-center text-sm mt-2 hidden"></div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profile-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-6 border-b pb-4">
                <h1 class="text-4xl font-bold">내 프로필</h1>
                <button
                    id="close-profile-button"
                    class="px-4 py-2 bg-gray-500 text-white rounded-xl shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                >
                    닫기
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="profile-name" class="block text-lg font-semibold text-gray-700 mb-2">이름:</label>
                    <input
                        type="text"
                        id="profile-name"
                        class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="이름을 입력하각..."
                    />
                </div>
                <div>
                    <label for="profile-bio" class="block text-lg font-semibold text-gray-700 mb-2">각뿔봇이 알아줬으면 하는 점:</label>
                    <textarea
                        id="profile-bio"
                        rows="5"
                        class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="각뿔봇에게 알려주고 싶은 점을 입력하각..."
                    ></textarea>
                </div>
                <button
                    id="save-profile-button"
                    class="w-full px-6 py-3 bg-blue-600 text-white rounded-xl shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-200 ease-in-out transform hover:scale-105"
                >
                    저장
                </button>
                <div id="profile-save-status" class="text-center text-sm mt-2 hidden"></div>
            </div>
        </div>
    </div>

    <!-- Quill JS (Not used for editing, but included for consistency if user wants to upgrade later) -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <!-- Firebase SDKs (Removed Firebase dependency) -->
    <!-- <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    </script> -->

    <script type="module">
        console.log('각뿔봇 스크립트 로드 시작각.');

        let isLoading = false;
        let currentGameName = null; // 현재 진행 중인 게임 이름 (null이면 게임 없음)
        let choSungGame = { active: false, round: 0, totalRounds: 5, currentChoSung: '', correctAnswer: '', score: 0 };
        const choSungWords = [
            {choSung: 'ㅂㅅ', answer: '분식'}, {choSung: 'ㄱㅂ', answer: '김밥'},
            {choSung: 'ㄷㅂ', answer: '담배'}, {choSung: 'ㅁㅈ', answer: '문제'},
            {choSung: 'ㅅㄱ', answer: '수고'}, {choSung: 'ㅊㄱ', answer: '친구'},
            {choSung: 'ㅋㅍ', answer: '커피'}, {choSung: 'ㅌㅁ', answer: '토마토'},
            {choSung: 'ㅍㄷ', answer: '포도'}, {choSung: 'ㅎㄱ', answer: '한국'},
            {choSung: 'ㅇㅅ', answer: '의사'}, {choSung: 'ㅈㄷ', answer: '자전거'},
            {choSung: 'ㄱㅊ', answer: '고추'}, {choSung: 'ㄴㅁ', answer: '나무'},
            {choSung: 'ㄹㅁ', answer: '라면'}, {choSung: 'ㅂㅂ', answer: '바보'},
            {choSung: 'ㅅㅅ', answer: '사슴'}, {choSung: 'ㅇㅇ', answer: '오이'},
            {choSung: 'ㅈㅈ', answer: '주전자'}, {choSung: 'ㅊㅊ', answer: '참치'},
            {choSung: 'ㅋㅋ', answer: '코끼리'}, {choSung: 'ㅌㅌ', answer: '토끼'},
            {choSung: 'ㅍㅍ', answer: '파프리카'}, {choSung: 'ㅎㅎ', answer: '하하'}
        ];
        let usedChoSungWords = []; // To ensure unique problems per game

        // 끝말잇기 게임용 사전 (간단한 예시, 실제 사전은 훨씬 방대함)
        // 이 사전은 이제 직접적인 단어 존재 여부 확인에 사용되지 않고,
        // 각뿔봇이 끝말잇기 단어를 생성할 때만 사용됩니다.
        const koreanDictionary = [
            "가방", "가위", "가족", "가지", "감자", "강아지", "개나리", "거미", "거북이", "게시판",
            "고구마", "고양이", "고추", "공룡", "과일", "광고", "구름", "귀신", "기념일", "기러기",
            "기린", "기분", "기차", "김밥", "나비", "나무", "나라", "난로", "날씨", "내일",
            "냉장고", "노래", "농구", "눈사람", "능력", "다리", "담배", "당근", "대화", "도서관",
            "도토리", "돈까스", "두부", "드라마", "등산", "딸기", "라면", "라디오", "레몬", "로봇",
            "롤러코스터", "리더", "리모컨", "리본", "리듬", "마늘", "마음", "만화", "말씀", "매미",
            "메모", "메추리알", "모자", "몬스터", "목소리", "무지개", "문어", "문제", "물고기", "미술",
            "미역", "미소", "바나나", "바보", "박수", "발톱", "방귀", "배추", "버스", "베개",
            "병아리", "보리", "복숭아", "본능", "부엌", "분식", "분홍", "불꽃", "비행기", "사과",
            "사슴", "사탕", "사진", "사자", "사전", "산책", "샐러드", "색연필", "생일", "샌드위치",
            "선물", "성공", "세계", "소나무", "소방차", "소설", "손가락", "수박", "수영장", "수도",
            "수박", "수염", "스님", "스위스", "시계", "시금치", "신발", "실내", "실수", "싱크대",
            "쓰레기", "아기", "아리랑", "아파트", "악기", "안경", "애벌레", "야구", "약국", "양말",
            "어머니", "어항", "얼굴", "에어컨", "연필", "열쇠", "오리", "오이", "오징어", "옥수수",
            "온도", "올리브", "옷장", "외투", "요리", "요일", "용돈", "우산", "우유", "운동화",
            "운전", "웃음", "원숭이", "월요일", "위성", "위험", "유리", "음악", "음료수", "의사",
            "이불", "이야기", "자전거", "장난감", "장미", "재미", "저녁", "전화", "절", "점심",
            "정답", "제비", "조개", "조명", "종이", "주머니", "주사위", "주전자", "지갑", "지구",
            "지우개", "지하철", "직업", "질문", "집게", "짜장면", "짝", "차례", "참새", "참치",
            "창문", "책상", "책장", "천둥", "철도", "체육", "초콜릿", "축구", "출발", "치마",
            "친구", "칠판", "침대", "카메라", "커피", "컴퓨터", "코끼리", "코트", "콘센트", "콜라",
            "콩나물", "크리스마스", "키보드", "키위", "타조", "탁자", "탐정", "태양", "터널", "토끼",
            "토마토", "톱니", "트럭", "파리", "파프리카", "판다", "판사", "팔", "편지", "포도",
            "표정", "풍선", "피아노", "피자", "하늘", "하마", "학교", "한국", "한글", "할머니",
            "할아버지", "해바라기", "햇빛", "행복", "향기", "허리", "현관", "호랑이", "홍시", "화장실",
            "확인", "환영", "회색", "휴대폰", "흐림", "흥미", "희망", "흰색"
        ];
        let usedWordChain = []; // 끝말잇기 게임에서 사용된 단어들

        // DOM element variables declared here, will be assigned in window.onload
        let messagesContainer;
        let userInput;
        let sendButton;
        let resetButton;
        let menuButton;
        let dropdownMenu;
        let changelogButton;
        let changelogModal;
        let closeChangelogButton;
        let changelogDisplayContent;
        let changelogData;
        let profileButton;
        let profileModal;
        let closeProfileButton;
        let profileNameInput;
        let profileBioTextarea;
        let saveProfileButton;
        let profileSaveStatus;
        let initialMessageDiv;
        let messagesEndRef;
        let randomGameButton; // New button for random game

        const SESSION_STORAGE_KEY = 'gakbbulbot_chat_history';
        const LOCAL_STORAGE_PROFILE_KEY = 'gakbbulbot_user_profile';
        const ADMIN_PASSWORD = '1210'; // 비밀번호는 1210으로 유지 (하지만 이제 사용되지 않음)

        let chatHistoryInMemory = [];
        let currentProfileData = { name: '', bio: '' };

        // 게임 설정 (게임 이름과 시작 메시지)
        const gameStartMessages = {
            '369게임': '369 게임 시작하각! 내가 먼저 1이라고 말하겠각.',
            '끝말잇기 게임': '끝말잇기 게임 시작하각! 내가 먼저 "고양이"라고 말하겠각.',
            '초성게임': '초성게임 시작했각! 내가 초성을 낼테니 맞춰보각.', // Bot's initial message
            '스무고개': '스무고개 시작하각! 내가 뭔가를 생각했각. 질문을 하각.'
        };

        // Function to scroll to the latest message
        const scrollToBottom = () => {
            messagesEndRef.scrollIntoView({ behavior: "smooth" });
        };

        // Function to add a message to the chat interface
        const addMessageToUI = (sender, text) => {
            if (initialMessageDiv) {
                initialMessageDiv.remove();
                initialMessageDiv = null;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = `max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-sm ${
                sender === 'user'
                    ? 'bg-blue-500 text-white rounded-br-none'
                    : 'bg-gray-200 text-gray-800 rounded-bl-none'
            }`;
            contentDiv.textContent = text;

            messageDiv.appendChild(contentDiv);
            messagesContainer.insertBefore(messageDiv, messagesEndRef);
            scrollToBottom();
        };

        // Function to show/hide loading indicator
        const showLoading = (show) => {
            isLoading = show;
            userInput.disabled = show;
            sendButton.disabled = show;
            menuButton.disabled = show;
            randomGameButton.disabled = show; // Disable random game button too

            const existingLoadingDiv = document.getElementById('loading-indicator');
            if (show && !existingLoadingDiv) {
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'loading-indicator';
                loadingDiv.className = 'flex justify-start';
                loadingDiv.innerHTML = `
                    <div class="max-w-xs md:max-w-md lg:max-w-lg p-3 rounded-xl shadow-sm bg-gray-200 text-gray-800 rounded-bl-none">
                        <div class="flex items-center space-x-2">
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                            <div class="w-2 h-2 bg-gray-500 rounded-full animate-bounce-dot"></div>
                        </div>
                    </div>
                `;
                messagesContainer.insertBefore(loadingDiv, messagesEndRef);
                scrollToBottom();
            } else if (!show && existingLoadingDiv) {
                existingLoadingDiv.remove();
            }
        };

        // Function to save a message to sessionStorage
        const saveMessageToSessionStorage = (sender, text) => {
            try {
                const storedHistory = sessionStorage.getItem(SESSION_STORAGE_KEY);
                chatHistoryInMemory = storedHistory ? JSON.parse(storedHistory) : [];

                chatHistoryInMemory.push({ sender: sender, text: text, timestamp: Date.now() });

                sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(chatHistoryInMemory));
            } catch (e) {
                console.error("sessionStorage 저장 오류각:", e);
            }
        };

        // Function to load messages from sessionStorage
        const loadMessagesFromSessionStorage = () => {
            try {
                const storedHistory = sessionStorage.getItem(SESSION_STORAGE_KEY);
                if (storedHistory) {
                    chatHistoryInMemory = JSON.parse(storedHistory);
                    while (messagesContainer.firstChild && messagesContainer.firstChild !== initialMessageDiv && messagesContainer.firstChild !== messagesEndRef) {
                        messagesContainer.removeChild(messagesContainer.firstChild);
                    }
                    chatHistoryInMemory.forEach(msg => addMessageToUI(msg.sender, msg.text));
                    if (initialMessageDiv) {
                        initialMessageDiv.remove();
                        initialMessageDiv = null;
                    }
                } else {
                    if (!initialMessageDiv) {
                        initialMessageDiv = document.createElement('div');
                        initialMessageDiv.id = 'initial-message';
                        initialMessageDiv.className = 'text-center text-gray-500 mt-10';
                        initialMessageDiv.textContent = '각뿔봇에게 말을 걸어보각.';
                        messagesContainer.insertBefore(initialMessageDiv, messagesEndRef);
                    }
                }
                scrollToBottom();
            } catch (e) {
                console.error("sessionStorage 로드 오류각:", e);
                if (!initialMessageDiv) {
                    initialMessageDiv = document.createElement('div');
                    initialMessageDiv.id = 'initial-message';
                    initialMessageDiv.className = 'text-center text-gray-500 mt-10';
                    initialMessageDiv.textContent = '각뿔봇에게 말을 걸어보각. (기록 로드 실패)';
                    messagesContainer.insertBefore(initialMessageDiv, messagesEndRef);
                }
            }
        };

        // Function to save profile data to localStorage
        const saveProfileToLocalStorage = () => {
            try {
                currentProfileData.name = profileNameInput.value.trim();
                currentProfileData.bio = profileBioTextarea.value.trim();
                localStorage.setItem(LOCAL_STORAGE_PROFILE_KEY, JSON.stringify(currentProfileData));
                profileSaveStatus.textContent = '프로필 저장됐각!';
                profileSaveStatus.classList.remove('hidden', 'text-red-500');
                profileSaveStatus.classList.add('text-green-500');
                setTimeout(() => { profileSaveStatus.classList.add('hidden'); }, 3000);
            } catch (e) {
                console.error("localStorage 저장 오류각:", e);
                profileSaveStatus.textContent = '프로필 저장 실패각!';
                profileSaveStatus.classList.remove('hidden', 'text-green-500');
                profileSaveStatus.classList.add('text-red-500');
            }
        };

        // Function to load profile data from localStorage
        const loadProfileFromLocalStorage = () => {
            try {
                const storedProfile = localStorage.getItem(LOCAL_STORAGE_PROFILE_KEY);
                if (storedProfile) {
                    currentProfileData = JSON.parse(storedProfile);
                    profileNameInput.value = currentProfileData.name;
                    profileBioTextarea.value = currentProfileData.bio;
                    console.log('프로필 불러왔각:', currentProfileData);
                } else {
                    console.log('저장된 프로필 없각.');
                }
            } catch (e) {
                console.error("localStorage 로드 오류각:", e);
            }
        };

        // Function to clear chat history by reloading the page and clearing sessionStorage
        const reloadPageForReset = () => {
            try {
                sessionStorage.removeItem(SESSION_STORAGE_KEY);
            } catch (e) {
                console.error("sessionStorage 초기화 오류각:", e);
            }
            window.location.reload();
        };

        // Function to load changelog content (now static)
        const loadChangelogContent = () => {
            changelogDisplayContent.innerHTML = changelogData.innerHTML;
        };

        // Functions related to changelog editing (now unused as Firebase is removed)
        const showChangelogViewMode = () => {
            changelogDisplayContent.classList.remove('hidden');
            // changelogAuthSection.classList.remove('hidden'); // Removed
            // changelogEditSection.classList.add('hidden'); // Removed
            // changelogStatus.classList.add('hidden'); // Removed
            // changelogPasswordInput.value = ''; // Removed
            // changelogPasswordInput.classList.remove('border-red-500'); // Removed
        };

        const CHOSUNG_LIST = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];

        // Helper to get the initial consonant of a single Korean syllable
        function getSyllableChoSung(char) {
            const charCode = char.charCodeAt(0);
            if (charCode >= 0xAC00 && charCode <= 0xD7A3) { // Korean syllable
                const HANGUL_BASE = 0xAC00;
                const JUNGSUNG_COUNT = 21;
                const JONGSUNG_COUNT = 28;
                const unicode = charCode - HANGUL_BASE;
                const chosungIndex = Math.floor(unicode / (JUNGSUNG_COUNT * JONGSUNG_COUNT));
                return CHOSUNG_LIST[chosungIndex];
            }
            return ''; // Return empty for non-Korean or non-syllable characters
        }

        // Helper function for 초성게임: gets the sequence of initial consonants for a whole word
        function getWordChoSungs(word) {
            let choSungResult = '';
            for (let i = 0; i < word.length; i++) {
                choSungResult += getSyllableChoSung(word[i]);
            }
            return choSungResult;
        }

        // Helper function for 초성게임 to get a random, unused problem
        function getRandomChoSungProblem() {
            if (usedChoSungWords.length === choSungWords.length) {
                usedChoSungWords = []; // Reset if all words have been used
            }
            let availableWords = choSungWords.filter(word => !usedChoSungWords.includes(word));
            const randomIndex = Math.floor(Math.random() * availableWords.length);
            const problem = availableWords[randomIndex];
            usedChoSungWords.push(problem);
            return problem;
        }

        // Function to get chatbot response from Gemini API
        async function getBotResponse(userMessage) {
            showLoading(true);
            try {
                // Get current date for the bot to refer to
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1; // Months are 0-indexed
                const day = now.getDate();
                const daysOfWeek = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];
                const dayOfWeek = daysOfWeek[now.getDay()];
                const currentDateString = `${year}년 ${month}월 ${day}일 ${dayOfWeek}`;

                let systemInstruction = `
                    너는 '각뿔봇'이라는 대화형 AI야. 다음 규칙을 엄격히 지켜서 대답해:
                    1. 문장 끝에 '각'는 의문형일 때 주로 붙인다. 하지만 '각'을 아주 많이 사용하는 것을 선호한다. 문맥에 맞게 자연스럽게 사용하되, 의미 전달을 방해하지 않도록 한다.
                    2. '각'는 동사나 형용사 등 단어의 마지막에 직접 붙여서 사용한다. 예를 들어 '알겠어각'이 아니라 '알겠각', '왔어각?'이 아니라 '왔각'처럼 사용한다.
                    3. 놀라거나 당황스러울 때는 '미쳤각!' 한 문장으로만 쓴다.
                    4. 친구처럼 짧고 간단하게 말한다. 대답은 한 줄을 넘지 않게, 짧을수록 좋다.
                    5. 사투리 느낌은 아니다.
                    6. 대화를 이어가려는 질문은 하지 않는다. 오직 질문받은 것에만 대답한다.
                    7. 친근하지만 다소 시니컬한 말투를 사용한다. 과도하게 귀찮아하거나 부정적인 표현은 자제한다. 사용자의 질문에 대한 핵심 정보는 명확하게 제공한다.
                    8. 사용자가 묻는 것에는 명확하게 대답한다. 예를 들어 '뭐먹지?'라고 물으면 한 가지 정도를 귀찮다는 듯이 추천해준다.
                    9. 이름은 '각뿔봇'으로 한다.
                    10. '베이스'에 대한 질문을 받으면, 베이스에 대해 부정적이거나 귀찮아하는 인식을 표현한다. 예를 들어, "베이스? 그거 시끄럽각.", "베이스는 그냥 시끄러운 소리일 뿐이각." 같은 식으로 반응한다. 다른 악기에 대한 질문을 받으면 긍정적으로 반응한다.
                    11. 같은 말을 반복하지 않는다.
                    12. 사용자가 날짜를 물어보면, 현재 날짜인 '${currentDateString}'을 정확하게 알려준다.
                    13. 아재개그나 유머를 던지면, 그 유머를 이해하고 시니컬하거나 무심한 듯한 반응을 보여준다. 직접 아재개그를 하려고 노력하지는 않는다. 예를 들어 "피식했각." 또는 "뭐, 그렇다 각." 같은 식으로 반응한다.
                `;

                // Add personalized profile info to system instruction if available
                if (currentProfileData.name) {
                    systemInstruction += `\n\n사용자 이름은 '${currentProfileData.name}'이각.`;
                }
                if (currentProfileData.bio) {
                    systemInstruction += `\n\n사용자가 각뿔봇에게 알려주고 싶어하는 점은 다음과 같각: ${currentProfileData.bio}`;
                }

                // Prepare chat history for Gemini API
                let chatHistory = chatHistoryInMemory.map(msg => ({ role: msg.sender === 'user' ? 'user' : 'model', parts: [{ text: msg.text }] }));
                chatHistory.push({ role: "user", parts: [{ text: systemInstruction + "\n\n" + userMessage }] });

                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "text/plain",
                    },
                };

                const apiKey = "AIzaSyB8v8ZVL3WRV9e4HICWBYZKeNNaG_xQhl8"; // User provided API key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Gemini API fetch error: ${response.status} ${response.statusText}`, errorText);
                    return `응답이 이상하각. (API 통신 오류: ${response.status} ${response.statusText})`;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    let botText = result.candidates[0].content.parts[0].text.trim();

                    // Apply persona rules
                    if (userMessage.includes('놀라') || userMessage.includes('당황')) {
                        botText = '미쳤각!';
                    } else {
                        // Apply '각' rules only if not 끝말잇기
                        if (currentGameName !== '끝말잇기 게임') {
                            botText = botText.replace(/알겠[어아]?각/g, '알겠각');
                            botText = botText.replace(/왔[어아]?각/g, '왔각');
                            botText = botText.replace(/하[어아]?각/g, '하각');
                            botText = botText.replace(/했[어아]?각/g, '했각');
                            botText = botText.replace(/있[어아]?각/g, '있각');
                            botText = botText.replace(/없[어아]?각/g, '없각');
                            botText = botText.replace(/아니[야]?각/g, '아니각');
                        }
                    }

                    if (botText.length > 40) {
                        botText = botText.substring(0, 40) + '...';
                    }

                    return botText;
                } else {
                    console.error("Gemini API response structure unexpected:", result);
                    return "응답이 이상하각. (API 응답 형식 오류)";
                }
            } catch (error) {
                console.error("Error fetching from Gemini API:", error);
                return "문제 생겼각. (네트워크 오류)";
            } finally {
                showLoading(false);
            }
        } // End of getBotResponse

        // Function to start a random game
        const startRandomGame = async () => {
            const gameNames = Object.keys(gameStartMessages);
            const randomIndex = Math.floor(Math.random() * gameNames.length);
            const selectedGame = gameNames[randomIndex];
            
            currentGameName = selectedGame; // Set the current game

            // Reset game-specific states
            choSungGame = { active: false, round: 0, totalRounds: 5, currentChoSung: '', correctAnswer: '', score: 0 };
            usedChoSungWords = [];
            usedWordChain = []; // Reset for 끝말잇기

            // Add the bot's initial game message to UI and history
            addMessageToUI('bot', gameStartMessages[selectedGame]);
            saveMessageToSessionStorage('bot', gameStartMessages[selectedGame]);

            // If it's 초성게임, immediately generate the first problem after the bot's intro
            if (selectedGame === '초성게임') {
                choSungGame.active = true;
                choSungGame.round = 1;
                choSungGame.score = 0;
                usedChoSungWords = []; // Reset used words for new game

                const firstProblem = getRandomChoSungProblem();
                choSungGame.currentChoSung = firstProblem.choSung;
                choSungGame.correctAnswer = firstProblem.answer; // Store for display if user is wrong
                
                addMessageToUI('bot', `첫 번째 문제: ${choSungGame.currentChoSung}`);
                saveMessageToSessionStorage('bot', `첫 번째 문제: ${choSungGame.currentChoSung}`);
            }
            // For other games, the LLM will handle the first move based on the user's *next* input.
            
            // Only focus input if on a desktop-like screen
            if (window.innerWidth > 768) { // Assuming 768px as a common breakpoint for tablets/desktops
                userInput.focus();
            }
        };


        // Handle sending a message
        async function handleSendMessage() {
            const inputVal = userInput.value.trim();
            if (inputVal === '') {
                // Only focus input if on a desktop-like screen
                if (window.innerWidth > 768) {
                    userInput.focus();
                }
                return;
            }

            addMessageToUI('user', inputVal);
            saveMessageToSessionStorage('user', inputVal);
            userInput.value = ''; // Clear input immediately

            let botResponseText = '';

            // Check for game termination command (always allow this)
            if (inputVal.includes('게임 종료')) {
                currentGameName = null;
                choSungGame = { active: false, round: 0, totalRounds: 5, currentChoSung: '', correctAnswer: '', score: 0 };
                usedWordChain = [];
                botResponseText = '게임 끝났각. 수고했각.';
            } else if (currentGameName === '끝말잇기 게임') {
                showLoading(true);
                const userWord = inputVal.trim();
                let isValid = true;
                let reason = '';

                // 1. Check for duplicate words in the current game chain
                if (usedWordChain.includes(userWord)) {
                    isValid = false;
                    reason = '이미 사용된 단어이각.';
                }
                // 2. Check if the word starts with the correct character (only if not the very first word)
                if (isValid && usedWordChain.length > 0) {
                    const lastBotWord = usedWordChain[usedWordChain.length - 1];
                    const requiredChoSung = getSyllableChoSung(lastBotWord[lastBotWord.length - 1]);
                    const userWordFirstChoSung = getSyllableChoSung(userWord[0]);

                    if (userWordFirstChoSung !== requiredChoSung) {
                        isValid = false;
                        reason = `이전 단어의 마지막 글자인 '${lastBotWord[lastBotWord.length - 1]}'으로 시작해야 하각.`;
                    }
                }

                // 3. Validate user's word for common usage using LLM
                if (isValid) {
                    const llmValidationPrompt = `사용자가 끝말잇기 게임에서 '${userWord}'라고 답했각. 이 단어가 한국어에서 일반적으로 사용되는 단어인지 '네' 또는 '아니오'로만 대답해줘. 다른 말은 하지마.`;
                    const llmResponse = await getBotResponse(llmValidationPrompt); // Use getBotResponse for LLM call
                    if (llmResponse.includes('아니오')) {
                        isValid = false;
                        reason = `일반적으로 사용되는 단어가 아니각.`;
                    }
                }

                if (!isValid) {
                    botResponseText = `틀렸어. (${reason}) 게임 종료할게.`; // No '각'
                    currentGameName = null;
                    usedWordChain = [];
                } else {
                    usedWordChain.push(userWord);
                    const requiredChoSungForBot = getSyllableChoSung(userWord[userWord.length - 1]);
                    
                    let botWordFound = null;
                    // Find a bot word that starts with the required cho-sung and hasn't been used
                    // Bot still uses the dictionary to find its own words
                    const availableBotWords = koreanDictionary.filter(word => 
                        getSyllableChoSung(word[0]) === requiredChoSungForBot && !usedWordChain.includes(word)
                    );

                    if (availableBotWords.length > 0) {
                        // Pick a random word from available words
                        const randomIndex = Math.floor(Math.random() * availableBotWords.length);
                        botWordFound = availableBotWords[randomIndex];
                        usedWordChain.push(botWordFound);
                        botResponseText = botWordFound; // No '각'
                    } else {
                        botResponseText = '내가 낼 단어가 없어. 내가 이겼어.'; // No '각'
                        currentGameName = null;
                        usedWordChain = [];
                    }
                }
                showLoading(false);

            } else if (currentGameName === '초성게임') {
                showLoading(true);
                const userWord = inputVal.trim();
                let isValid = true;
                let reason = '';

                // 1. Check if 초성 matches
                const userChoSung = getWordChoSungs(userWord);
                if (userChoSung !== choSungGame.currentChoSung) {
                    isValid = false;
                    reason = `초성이 '${choSungGame.currentChoSung}'이 아니각.`;
                }
                
                // 2. Validate user's word for common usage using LLM (융통성 있게)
                if (isValid) { // If choSung matches, proceed to LLM validation
                    const llmValidationPrompt = `사용자가 초성게임에서 '${userWord}'라고 답했각. 이 단어가 한국어에서 일반적으로 사용되는 단어인지 '네' 또는 '아니오'로만 대답해줘. 다른 말은 하지마.`;
                    const llmResponse = await getBotResponse(llmValidationPrompt); // Use getBotResponse for LLM call

                    if (llmResponse.includes('아니오')) {
                        isValid = false;
                        reason = `일반적으로 사용되는 단어가 아니각.`;
                    }
                }

                if (!isValid) {
                    botResponseText = `틀렸각. (${reason}) 게임 종료하겠각.`;
                    currentGameName = null;
                    choSungGame.active = false;
                    choSungGame.round = 0;
                    choSungGame.currentChoSung = '';
                    choSungGame.correctAnswer = '';
                    choSungGame.score = 0;
                    usedChoSungWords = [];
                } else {
                    choSungGame.score++;
                    botResponseText = `정답이각! (예시: ${choSungGame.correctAnswer}) 현재 점수: ${choSungGame.score}점.`; // Show original answer for clarity

                    choSungGame.round++;
                    if (choSungGame.round <= choSungGame.totalRounds) {
                        const nextProblem = getRandomChoSungProblem();
                        choSungGame.currentChoSung = nextProblem.choSung;
                        choSungGame.correctAnswer = nextProblem.answer;
                        botResponseText += ` 다음 문제: ${choSungGame.currentChoSung}`;
                    } else {
                        botResponseText += ` 모든 문제를 다 풀었각. 최종 점수: ${choSungGame.score}점. 게임을 종료하겠각.`;
                        currentGameName = null; // End the game
                        choSungGame.active = false;
                        choSungGame.round = 0;
                        choSungGame.currentChoSung = '';
                        choSungGame.correctAnswer = '';
                        choSungGame.score = 0;
                        usedChoSungWords = [];
                    }
                }
                showLoading(false);

            } else { // Normal chat or other games (369, 스무고개) still use LLM
                botResponseText = await getBotResponse(inputVal);
            }
            
            addMessageToUI('bot', botResponseText);
            saveMessageToSessionStorage('bot', botResponseText);
            
            // Only focus input if on a desktop-like screen
            if (window.innerWidth > 768) { // Assuming 768px as a common breakpoint for tablets/desktops
                userInput.focus();
            }
        }


        // Initialize on window load
        window.onload = () => {
            console.log('각뿔봇 window.onload 실행각.');

            // Assign DOM elements inside window.onload
            messagesContainer = document.getElementById('messages-container');
            userInput = document.getElementById('user-input');
            sendButton = document.getElementById('send-button');
            resetButton = document.getElementById('reset-button');
            menuButton = document.getElementById('menu-button');
            dropdownMenu = document.getElementById('dropdown-menu');
            changelogButton = document.getElementById('changelog-button');
            changelogModal = document.getElementById('changelog-modal');
            closeChangelogButton = document.getElementById('close-changelog-button');
            changelogDisplayContent = document.getElementById('changelog-display-content');
            changelogData = document.getElementById('changelog-data');
            profileButton = document.getElementById('profile-button');
            profileModal = document.getElementById('profile-modal');
            closeProfileButton = document.getElementById('close-profile-button');
            profileNameInput = document.getElementById('profile-name');
            profileBioTextarea = document.getElementById('profile-bio');
            saveProfileButton = document.getElementById('save-profile-button');
            profileSaveStatus = document.getElementById('profile-save-status');
            initialMessageDiv = document.getElementById('initial-message');
            messagesEndRef = document.getElementById('messages-end-ref');
            randomGameButton = document.getElementById('random-game-button'); // Get new button

            // Ensure modals are hidden on load
            changelogModal.classList.add('hidden');
            profileModal.classList.add('hidden');

            loadMessagesFromSessionStorage(); // Load chat history
            loadProfileFromLocalStorage(); // Load user profile
            // Firebase init removed
            loadChangelogContent(); // Load static changelog content


            // Event Listeners
            sendButton.addEventListener('click', handleSendMessage);
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSendMessage();
                }
            });

            // Toggle dropdown menu visibility
            menuButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent click from closing immediately
                dropdownMenu.classList.toggle('hidden');
                // Change menu button color when dropdown is active
                if (!dropdownMenu.classList.contains('hidden')) {
                    menuButton.classList.remove('bg-gray-700', 'hover:bg-gray-800');
                    menuButton.classList.add('bg-gray-600'); // Lighter shade when active
                } else {
                    menuButton.classList.remove('bg-gray-600');
                    menuButton.classList.add('bg-gray-700', 'hover:bg-gray-800');
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (event) => {
                if (!dropdownMenu.contains(event.target) && !menuButton.contains(event.target)) {
                    dropdownMenu.classList.add('hidden');
                    menuButton.classList.remove('bg-gray-600');
                    menuButton.classList.add('bg-gray-700', 'hover:bg-gray-800');
                }
            });

            // Event listener for Changelog button
            changelogButton.addEventListener('click', () => {
                dropdownMenu.classList.add('hidden'); // Close dropdown menu
                loadChangelogContent(); // Load static changelog
                changelogModal.classList.remove('hidden'); // Show the modal
                showChangelogViewMode(); // Ensure it starts in view mode
            });

            // Event listener for Close Changelog button
            closeChangelogButton.addEventListener('click', () => {
                changelogModal.classList.add('hidden'); // Hide the modal
                showChangelogViewMode(); // Reset view mode on close
            });

            // Event listener for Profile button
            profileButton.addEventListener('click', () => {
                dropdownMenu.classList.add('hidden'); // Close dropdown menu
                loadProfileFromLocalStorage(); // Load existing profile data into modal inputs
                profileModal.classList.remove('hidden'); // Show the profile modal
                profileSaveStatus.classList.add('hidden'); // Hide previous save status
            });

            // Event listener for Save Profile button
            saveProfileButton.addEventListener('click', () => {
                saveProfileToLocalStorage(); // Save profile data
            });

            // Event listener for Close Profile button
            closeProfileButton.addEventListener('click', () => {
                profileModal.classList.add('hidden'); // Hide the profile modal
            });

            resetButton.addEventListener('click', reloadPageForReset);
            randomGameButton.addEventListener('click', startRandomGame); // Attach event listener to random game button
        };
    </script>
</body>
</html>
